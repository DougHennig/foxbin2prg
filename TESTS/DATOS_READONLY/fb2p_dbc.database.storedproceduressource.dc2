*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="fb2p_dbc.dbc" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
	<STOREDPROCEDURES><![CDATA[
PROCEDURE ins_trg
	STRTOFILE( PROGRAM(), FORCEPATH( "LOG_DBC.TXT", JUSTPATH( EVL( DBC(),DBF() ) ) ) )
ENDPROC
PROCEDURE upd_trg
	STRTOFILE( PROGRAM(), FORCEPATH( "LOG_DBC.TXT", JUSTPATH( EVL( DBC(),DBF() ) ) ) )
ENDPROC
PROCEDURE del_trg
	STRTOFILE( PROGRAM(), FORCEPATH( "LOG_DBC.TXT", JUSTPATH( EVL( DBC(),DBF() ) ) ) )
ENDPROC
PROCEDURE depto_field_validation_rule
ENDPROC
PROCEDURE depto_field_validation_message
	RETURN 'Mensaje para Field Rule "depto_field_validation_rule"'
ENDPROC
PROCEDURE fb2p_depto_record_rule_validation
ENDPROC
PROCEDURE fb2p_depto_record_rule_validation_message
	RETURN 'Mensaje para Record Rule "fb2p_depto_record_rule_validation"'
ENDPROC
PROCEDURE depto_field_def_value
	RETURN 'Dpto.'
ENDPROC

PROCEDURE dbc_OpenData
	LPARAMETERS cDatabaseName, lExclusive, lNoUpdate, lValidate
*	? '     cDatabaseName = ' + TRANSFORM(cDatabaseName) + ' - ' + TYPE('cDatabaseName')
*	? '     lExclusive    = ' + TRANSFORM(lExclusive) + ' - ' + TYPE('lExclusive')
*	? '     lNoUpdate     = ' + TRANSFORM(lNoUpdate)  + ' - ' + TYPE('lNoUpdate')
*	? '     lValidate     = ' + TRANSFORM(lValidate)  + ' - ' + TYPE('lValidate')
ENDPROC

**__RI_HEADER!@ Do NOT REMOVE or MODIFY this line!!!! @!__RI_HEADER**
PROCEDURE RIDELETE
	LOCAL llRetVal
	llRetVal=.T.
	IF (ISRLOCKED() AND !DELETED()) OR !RLOCK()
		llRetVal=.F.
	ELSE
		IF !DELETED()
			DELETE
			IF CURSORGETPROP('BUFFERING') > 1
				=TABLEUPDATE()
			ENDIF
		ENDIF NOT already DELETED
	ENDIF
	UNLOCK RECORD (RECNO())
	llRetVal=pnerror=0
	RETURN llRetVal

PROCEDURE RIUPDATE
	LPARAMETERS tcFieldName,tcNewValue,tcCascadeParent
	LOCAL llRetVal
	llRetVal=.T.
	IF ISRLOCKED() OR !RLOCK()
		llRetVal=.F.
	ELSE
		IF EVAL(tcFieldName)<>tcNewValue
			PRIVATE pcCascadeParent
			pcCascadeParent=UPPER(IIF(TYPE("tcCascadeParent")<>"C","",tcCascadeParent))
			REPLACE (tcFieldName) WITH tcNewValue
			IF CURSORGETPROP('BUFFERING') > 1
				=TABLEUPDATE()
			ENDIF
		ENDIF VALUES don't already match
	ENDIF it's locked already, or I was able to lock it
	UNLOCK RECORD (RECNO())
	llRetVal=pnerror=0
	RETURN llRetVal

PROCEDURE rierror
	PARAMETERS tnErrNo,tcMessage,tcCode,tcProgram
	LOCAL lnErrorRows,lnXX
	lnErrorRows=ALEN(gaErrors,1)
	IF TYPE('gaErrors[lnErrorRows,1]')<>"L"
		DIMENSION gaErrors[lnErrorRows+1,alen(gaErrors,2)]
		lnErrorRows=lnErrorRows+1
	ENDIF
	gaErrors[lnErrorRows,1]=tnErrNo
	gaErrors[lnErrorRows,2]=tcMessage
	gaErrors[lnErrorRows,3]=tcCode
	gaErrors[lnErrorRows,4]=""
	lnXX=1
	DO WHILE !EMPTY(PROGRAM(lnXX))
		gaErrors[lnErrorRows,4]=gaErrors[lnErrorRows,4]+","+;
			PROGRAM(lnXX)
		lnXX=lnXX+1
	ENDDO
	gaErrors[lnErrorRows,5]=pcParentDBF
	gaErrors[lnErrorRows,6]=pnParentRec
	gaErrors[lnErrorRows,7]=pcParentID
	gaErrors[lnErrorRows,8]=pcParentExpr
	gaErrors[lnErrorRows,9]=pcChildDBF
	gaErrors[lnErrorRows,10]=pnChildRec
	gaErrors[lnErrorRows,11]=pcChildID
	gaErrors[lnErrorRows,12]=pcChildExpr
	RETURN tnErrNo


PROCEDURE riopen
	PARAMETERS tcTable,tcOrder

	LOCAL lcCurWkArea,lcNewWkArea,lnInUseSpot,lnOccurs,lnOccurance
	lnInUseSpot=0
	lnOccurs = OCCURS(UPPER(tcTable)+"*",UPPER(pcRIcursors))
	FOR lnOccurance = 1 TO lnOccurs
		lnInUseSpot=ATC(tcTable+"*",pcRIcursors,lnOccurance)
		IF ISDIGIT(SUBSTR(pcRIcursors,lnInUseSpot-1,1)) OR;
				EMPTY(SUBSTR(pcRIcursors,lnInUseSpot-1,1))
			EXIT
		ENDIF
		lnInUseSpot=0
	ENDFOR

	IF lnInUseSpot=0
		lcCurWkArea=SELECT()
		SELECT 0
		lcNewWkArea=SELECT()
		IF NOT EMPTY(tcOrder)
			USE (tcTable) AGAIN ORDER (tcOrder) ;
				ALIAS ("__ri"+LTRIM(STR(SELECT()))) SHARE
		ELSE
			USE (tcTable) AGAIN ALIAS ("__ri"+LTRIM(STR(SELECT()))) SHARE
		ENDIF
		IF pnerror=0
			pcRIcursors=pcRIcursors+UPPER(tcTable)+"?"+STR(SELECT(),5)
		ELSE
			lcNewWkArea=0
		ENDIF something bad happened WHILE attempting TO OPEN the FILE
	ELSE
		lcNewWkArea=VAL(SUBSTR(pcRIcursors,lnInUseSpot+LEN(tcTable)+1,5))
		pcRIcursors = STRTRAN(pcRIcursors,UPPER(tcTable)+"*"+STR(lcNewWkArea,5),;
			UPPER(tcTable)+"?"+STR(lcNewWkArea,5))
		IF NOT EMPTY(tcOrder)
			SET ORDER TO (tcOrder) IN (lcNewWkArea)
		ENDIF sent an ORDER
		IF pnerror<>0
			lcNewWkArea=0
		ENDIF something bad happened WHILE setting ORDER
	ENDIF
	RETURN (lcNewWkArea)


PROCEDURE riend
	PARAMETERS tlSuccess
	LOCAL lnXX,lnSpot,lcWorkArea
	IF tlSuccess
		END TRANSACTION
	ELSE
		SET DELETED OFF
		ROLLBACK
		SET DELETED ON
	ENDIF
	IF EMPTY(pcRIolderror)
		ON ERROR
	ELSE
		ON ERROR &pcRIolderror.
	ENDIF
	FOR lnXX=1 TO OCCURS("*",pcRIcursors)
		lnSpot=ATC("*",pcRIcursors,lnXX)+1
		USE IN (VAL(SUBSTR(pcRIcursors,lnSpot,5)))
	ENDFOR
	IF pcOldCompat = "ON"
		SET COMPATIBLE ON
	ENDIF
	IF pcOldDele="OFF"
		SET DELETED OFF
	ENDIF
	IF pcOldExact="ON"
		SET EXACT ON
	ENDIF
	IF pcOldTalk="ON"
		SET TALK ON
	ENDIF
	DO CASE
	CASE EMPTY(pcOldDBC)
		SET DATA TO
	CASE pcOldDBC<>DBC()
		SET DATA TO (pcOldDBC)
	ENDCASE
	RETURN .T.


PROCEDURE rireuse
	* rireuse.prg
	PARAMETERS tcTableName,tcWkArea
	pcRIcursors = STRTRAN(pcRIcursors,UPPER(tcTableName)+"?"+STR(tcWkArea,5),;
		UPPER(tcTableName)+"*"+STR(tcWkArea,5))
	RETURN .T.

	********************************************************************************
	** "Referential integrity delete trigger for" fb2p_depto
PROCEDURE __RI_DELETE_fb2p_depto
	LOCAL llRetVal
	llRetVal = .T.
	PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
	PRIVATE pcParentExpr,pcChildExpr
	STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
	STORE 0 TO pnParentRec,pnChildRec
	IF _TRIGGERLEVEL=1
		BEGIN TRANSACTION
		PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
			pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,pcOldDBC
		pcOldTalk=SET("TALK")
		SET TALK OFF
		pcOldDele=SET("DELETED")
		pcOldExact=SET("EXACT")
		pcOldCompat=SET("COMPATIBLE")
		SET COMPATIBLE OFF
		SET DELETED ON
		SET EXACT OFF
		pcRIcursors=""
		pcRIwkareas=""
		pcRIolderror=ON("error")
		pnerror=0
		ON ERROR pnerror=rierror(ERROR(),MESSAGE(),MESSAGE(1),PROGRAM())
		IF TYPE('gaErrors(1)')<>"U"
			RELEASE gaErrors
		ENDIF
		PUBLIC gaErrors(1,12)
		pcOldDBC=DBC()
		SET DATA TO ("FB2P_DBC")
	ENDIF FIRST TRIGGER
	LOCAL lcParentID && parent's value to be sought in child
	LOCAL lcChildWkArea && child work area handle returned by riopen
	LOCAL lcParentWkArea
	LOCAL llDelHeaderarea
	LOCAL lcStartArea
	lcStartArea=SELECT()
	llRetVal=.T.
	lcParentWkArea=SELECT()
	SELECT (lcParentWkArea)
	pcParentDBF=DBF()
	pnParentRec=RECNO()
	STORE DEPTO TO lcParentID,pcParentID
	pcParentExpr="DEPTO"
	lcChildWkArea=riopen("nombrelargodeldbf","depto")
	IF lcChildWkArea<=0
		IF _TRIGGERLEVEL=1
			DO riend WITH .F.
		ENDIF AT the END OF the highest TRIGGER LEVEL
		RETURN .F.
	ENDIF NOT able TO OPEN the CHILD WORK area
	pcChildDBF=DBF(lcChildWkArea)
	SELECT (lcChildWkArea)
	SEEK lcParentID
	SCAN WHILE DEPTO=lcParentID AND llRetVal
		pnChildRec=RECNO()
		pcChildID=DEPTO
		pcChildExpr="DEPTO"
		llRetVal=RIDELETE()
	ENDSCAN GET ALL OF the nombrelargodeldbf RECORDS
	=rireuse("nombrelargodeldbf",lcChildWkArea)
	IF NOT llRetVal
		IF _TRIGGERLEVEL=1
			DO riend WITH llRetVal
		ENDIF AT the END OF the highest TRIGGER LEVEL
		SELECT (lcStartArea)
		RETURN llRetVal
	ENDIF
	IF _TRIGGERLEVEL=1
		DO riend WITH llRetVal
	ENDIF AT the END OF the highest TRIGGER LEVEL
	SELECT (lcStartArea)
	RETURN llRetVal
	** "End of Referential integrity Delete trigger for" fb2p_depto
	********************************************************************************

	********************************************************************************
PROCEDURE __RI_UPDATE_nombrelargodeldbf
	** "Referential integrity update trigger for" nombrelargodeldbf
	LOCAL llRetVal
	llRetVal = .T.
	PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
	PRIVATE pcParentExpr,pcChildExpr
	STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
	STORE 0 TO pnParentRec,pnChildRec
	IF _TRIGGERLEVEL=1
		BEGIN TRANSACTION
		PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
			pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,pcOldDBC
		pcOldTalk=SET("TALK")
		SET TALK OFF
		pcOldDele=SET("DELETED")
		pcOldExact=SET("EXACT")
		pcOldCompat=SET("COMPATIBLE")
		SET COMPATIBLE OFF
		SET DELETED ON
		SET EXACT OFF
		pcRIcursors=""
		pcRIwkareas=""
		pcRIolderror=ON("error")
		pnerror=0
		ON ERROR pnerror=rierror(ERROR(),MESSAGE(),MESSAGE(1),PROGRAM())
		IF TYPE('gaErrors(1)')<>"U"
			RELEASE gaErrors
		ENDIF
		PUBLIC gaErrors(1,12)
		pcOldDBC=DBC()
		SET DATA TO ("FB2P_DBC")
	ENDIF FIRST TRIGGER
	LOCAL lcParentID && parent's value to be sought in child
	LOCAL lcOldParentID && previous parent id value
	LOCAL lcChildWkArea && child work area handle returned by riopen
	LOCAL lcChildID && child's value to be sought in parent
	LOCAL lcOldChildID && old child id value
	LOCAL lcParentWkArea && parentwork area handle returned by riopen
	LOCAL lcStartArea
	lcStartArea=SELECT()
	llRetVal=.T.
	lcChildWkArea=SELECT()
	IF _TRIGGERLEVEL=1 OR TYPE("pccascadeparent")#"C" OR (NOT pcCascadeParent=="FB2P_DEPTO")
		SELECT (lcChildWkArea)
		lcChildID=DEPTO
		lcOldChildID=OLDVAL("DEPTO")
		pcChildDBF=DBF(lcChildWkArea)
		pnChildRec=RECNO(lcChildWkArea)
		pcChildID=lcOldChildID
		pcChildExpr="DEPTO"
		IF ISNULL(lcChildID) OR ISNULL(lcOldChildID) OR lcChildID <> lcOldChildID
			lcParentWkArea=riopen("fb2p_depto","depto")
			IF lcParentWkArea<=0
				IF _TRIGGERLEVEL=1
					DO riend WITH .F.
				ENDIF AT the END OF the highest TRIGGER LEVEL
				SELECT (lcStartArea)
				RETURN .F.
			ENDIF NOT able TO OPEN the CHILD WORK area
			pcParentDBF=DBF(lcParentWkArea)
			llRetVal=SEEK(lcChildID,lcParentWkArea)
			pnParentRec=RECNO(lcParentWkArea)
			IF llRetVal AND NOT (ISRLOCKED(pnParentRec, lcParentWkArea) OR ;
					ISFLOCKED(lcParentWkArea))
				IF RLOCK(lcParentWkArea)
					UNLOCK RECORD pnParentRec IN (lcParentWkArea)
				ELSE
					=rireuse("tparen",lcParentWkArea)
					pnerror = rierror(-1,"Insert restrict rule violated.","","")
					IF _TRIGGERLEVEL=1
						DO riend WITH llRetVal
					ENDIF AT the END OF the highest TRIGGER LEVEL
					SELECT (lcStartArea)
					RETURN llRetVal
				ENDIF
			ENDIF
			=rireuse("fb2p_depto",lcParentWkArea)
			IF NOT llRetVal
				pnerror = rierror(-1,"Insert restrict rule violated.","","")
				IF _TRIGGERLEVEL=1
					DO riend WITH llRetVal
				ENDIF AT the END OF the highest TRIGGER LEVEL
				SELECT (lcStartArea)
				RETURN llRetVal
			ENDIF no PARENT
		ENDIF THIS VALUE was changed
	ENDIF NOT PART OF a CASCADE FROM "fb2p_depto"
	lcParentWkArea=lcChildWkArea
	IF _TRIGGERLEVEL=1
		DO riend WITH llRetVal
	ENDIF AT the END OF the highest TRIGGER LEVEL
	SELECT (lcStartArea)
	RETURN llRetVal
	** "End of Referential integrity Update trigger for" nombrelargodeldbf
	********************************************************************************

	********************************************************************************
	** "Referential integrity insert trigger for" nombrelargodeldbf
PROCEDURE __RI_INSERT_nombrelargodeldbf
	LOCAL llRetVal
	llRetVal = .T.
	PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
	PRIVATE pcParentExpr,pcChildExpr
	STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
	STORE 0 TO pnParentRec,pnChildRec
	IF _TRIGGERLEVEL=1
		BEGIN TRANSACTION
		PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
			pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,pcOldDBC
		pcOldTalk=SET("TALK")
		SET TALK OFF
		pcOldDele=SET("DELETED")
		pcOldExact=SET("EXACT")
		pcOldCompat=SET("COMPATIBLE")
		SET COMPATIBLE OFF
		SET DELETED ON
		SET EXACT OFF
		pcRIcursors=""
		pcRIwkareas=""
		pcRIolderror=ON("error")
		pnerror=0
		ON ERROR pnerror=rierror(ERROR(),MESSAGE(),MESSAGE(1),PROGRAM())
		IF TYPE('gaErrors(1)')<>"U"
			RELEASE gaErrors
		ENDIF
		PUBLIC gaErrors(1,12)
		pcOldDBC=DBC()
		SET DATA TO ("FB2P_DBC")
	ENDIF FIRST TRIGGER
	LOCAL lcChildID && child's value to be sought in parent
	LOCAL lcParentWkArea && parentwork area handle returned by riopen
	LOCAL lcChildWkArea && child's work area
	LOCAL lcStartArea
	lcStartArea=SELECT()
	llRetVal=.T.
	lcChildWkArea=SELECT()
	SELECT (lcChildWkArea)
	lcChildID=DEPTO
	pcChildDBF=DBF(lcChildWkArea)
	pnChildRec=RECNO(lcChildWkArea)
	pcChildID=lcChildID
	pcChildExpr="DEPTO"
	lcParentWkArea=riopen("fb2p_depto","depto")
	IF lcParentWkArea<=0
		IF _TRIGGERLEVEL=1
			DO riend WITH .F.
		ENDIF AT the END OF the highest TRIGGER LEVEL
		SELECT (lcStartArea)
		RETURN .F.
	ENDIF NOT able TO OPEN the CHILD WORK area
	pcParentDBF=DBF(lcParentWkArea)
	llRetVal=SEEK(lcChildID,lcParentWkArea)
	pnParentRec=RECNO(lcParentWkArea)
	IF llRetVal AND NOT (ISRLOCKED(pnParentRec, lcParentWkArea) OR ;
			ISFLOCKED(lcParentWkArea))
		IF RLOCK(lcParentWkArea)
			UNLOCK RECORD pnParentRec IN (lcParentWkArea)
		ELSE
			=rireuse("tparen",lcParentWkArea)
			pnerror = rierror(-1,"Insert restrict rule violated.","","")
			IF _TRIGGERLEVEL=1
				DO riend WITH llRetVal
			ENDIF AT the END OF the highest TRIGGER LEVEL
			SELECT (lcStartArea)
			RETURN llRetVal
		ENDIF
	ENDIF
	=rireuse("fb2p_depto",lcParentWkArea)
	IF NOT llRetVal
		pnerror = rierror(-1,"Insert restrict rule violated.","","")
		IF _TRIGGERLEVEL=1
			DO riend WITH llRetVal
		ENDIF AT the END OF the highest TRIGGER LEVEL
		SELECT (lcStartArea)
		RETURN llRetVal
	ENDIF
	IF _TRIGGERLEVEL=1
		DO riend WITH llRetVal
	ENDIF AT the END OF the highest TRIGGER LEVEL
	SELECT (lcStartArea)
	RETURN llRetVal
	** "End of Referential integrity insert trigger for" nombrelargodeldbf
	********************************************************************************
	**__RI_FOOTER!@ Do NOT REMOVE or MODIFY this line!!!! @!__RI_FOOTER**

	]]></STOREDPROCEDURES>